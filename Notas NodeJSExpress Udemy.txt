	Repositorio:
				https://github.com/Jonatandb/CursoUdemyIntroNodeJSExpress

	2. Instalado nodejs y visual studio code

		https://nodejs.org/es/download/
			https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi

		Actualizar NodeJS, cambiar versión de node con NPM
			http://blog.josmantek.com/nodejs/actualizar-nodejs-cambiar-version-node-npm/

		Consultar versión de Node:
			node -v

		Consultar versión de NPM:
			npm -v

		Conocer detalles sobre Node instalado:
			- Ejecutar la consola de Node
				(Buscar en programas instalados el acceso: Node.js)

			- Desde la consola ejecutar:
				process

			- Detalles principales:
				title: 'Node.js',
				version: 'v10.15.0',
				execPath: 'E:\\nodejs\\node.exe',

		VSCode:
			https://aka.ms/win32-x64-user-stable

		Extensiones:
			Terminal
			Prettier - Code formatter
			Git lens
			Git history
			VSCode-icons

	3. Ejecutando una app simple con nodejs

	4. Core Modules
		Funcionalidades simples o complejas que pueden ser reutilizados en una aplicación nodejs.
		Cada módulo tiene su propio contexto, por esto un módulo no puede interferir con otro.
		Cada módulo se coloca en un archivo .js diferente en una carpeta separada.

		Tipos de módulos:
			- Core
				Módulos que vienen por defecto cuando instalamos Node JS
				Ej:
					http	Permite ejecutar js del lado del servidor

			- Local

			- Third Party

	5. Local Modules

		Tipos de módulos:
			- Core
				Módulos que vienen por defecto cuando instalamos Node JS
				Ej:
					fs		Permite trabajar con archivos

			- Local
				Son los módulos que escribimos en nuestra aplicación

			- Third Party

	6. Importaciones parciales

		Cuando desde un módulo mío hago algo como:

			module.exports = { funcion1, funcion2 }

			Esto se conoce como una EXPORTACIÓN GLOBAL

		Para realizar exportaciones parciales, se debe exportar cada función
			de la siguiente manera:

				module.exports.inf = function info (param) {

		Para realicar importaciones parciales, se debe importar cada función
			de la siguiente manera:

				var { funcion1, funcion2 } = require('./modules/my-log')

		Otra manera de hacer una exportación parcial es escribir lo siguiente
			solo al final del archivo que tiene las funciones que deseo exportar:

				module.exports.info = info	// aquí exporto la función "info" (que debe
				haber sido declarada más arriba en mi arhcivo), con el nombre "info" (el
				cual debe ser el utilizado cuando se haga el require).
				* No es obligatorio que el nombre con el que se exporta sea igual al nombre
					de la función.

	7. Instalando un módulo desde NPM

		Tipos de módulos:

			- Third Party
				Son módulos desarrollados por otras personas

		Repositorio con módulos publicos disponibles para instalar con NPM:

			https://www.npmjs.com/

		Instalación de un módulo con npm:

			1º - Para poder instalar un módulo (paquete) con npm, primero debemos inicializar
				la carpeta donde estamos trabajando (lo que hará que pase a ser un paquete)
				Esto se hace ejecutando:
					npm init
				Se ingresan los datos solicitados por el asistente para establecer los detalles
				del paquete que se está creando.
				Esto genera un archivo llamado:
					package.json

			2º - Se instala el paquete deseado utilizando el comando siguiente:

				npm install nombreDelPaquete

				Ej:
					npm i countries-list
					* Es válido utilizar solo la letra "i", en lugar de "install"

				Esto agrega en el archivo package.json una nueva sección llamada
					"dependencies"
					la cual incluye el nombre del paquete externo del cual depende nuestro paquete.

				Junto con el nombre de la nueva dependencia, aparece la versión actual de la msima
				y a su vez éste número incluye delante el simbolo ^:
					"^2.5.1"
				Este simbolo le dice a NPM que cuando nuestro paquete sea instalado, se descargue
				e instale la dependencia indicada en su versión más actualizada (siempre y cuando
				la misma comienza con el 2). Pero esto puede traer un problema, que es que si al momento
				de instalarse alguien nuestro paquete, el desarrollador de la dependencia lanzó una
				nueva versión que mantiene como primer número el 2, pero que incluye cambios que rompen
				compatibilidad con versiones anteriores, lo que va a pasar es que nuestro paquete no va
				a funcionar.
				Para evitar esto es que entre NODE y NPM se acordó la creación de un nuevo archivo llamado
				"package-lock.json", el cual indica que versión expecífica de cada dependencia se debe
				instalar cuando se instale nuestro paquete, más allá de que en el package.json las mismas
				tengan delante de su número de versión el simbolo ^.

				También crea la carpeta "node_modules"
					Donde se descargarán los archivos de las dependencias instaladas.

		Creación de un script NPM

			En el archivo package.json, en la sección "Scripts", se agrega una nueva entrada
			con nombre "start" y luego de dos puntos se agrega su definición, ej:
				"start": "node index.js"

			Para ejecutar este script debo ejecutar:
				npm start 			//	o npm run start

		Uso del módulo core:	url
			El módulo url posee un método llamado parse() que recibe la propiedad url del objeto request:
				var parsed = url.parse(request.url)
			y devuelve un objeto llamado Url con toda la información de la url recibida:
				Url {
					protocol: null,
					slashes: null,
					auth: null,
					host: null,
					port: null,
					hostname: null,
					hash: null,
					search: '?code=AR',
					query: 'code=AR',
					pathname: '/country',
					path: '/country?code=AR',
					href: '/country?code=AR'
				}

		Uso del módulo core:	querystring
			El módulo querystring posee un método llamado parse que recibe una cadena con el formato
			"clave=valor&clave2=valor2":
				var query = querystring.parse('code=AR')
			y devuelve un objeto que posee propiedades con los nombres de las claves y como valores de
			las mismas los valores	luego de los signos de igual:
				Query: {
					code: 'AR'
				}

	8. Respaldar una app nodejs en un repositorio Git
		-	Inicializar un repositorio Git en la carpeta de nuestro proyecto ejecutando:
				git init
		-	Crear un nuevo repo en Github
		-	Copiarse la url del repo, por ej:
				https://github.com/Jonatandb/CursoUdemyIntroNodeJSExpress.git
		-	Crear en el raiz del proyecto un archivo llamado ".gitignore"
				Este archivo va a tener una entrada por cada carpeta y/o archivo que deseamos
					que Git no tenga en cuenta, para que no lo versione.
				Agregar por ejemplo:
					node_modules/
				** No agregar nunca el archivo package-lock.json!
		-	Desde la consola, parados en el raíz del proyecto, ejecutar:
				git remote add origin https://github.com/Jonatandb/CursoUdemyIntroNodeJSExpress.git
				Con esto vinculamos el repositorio local con el remoto en Github
		-	Crear rama local:
				git checkout -b nombreDeLaRama		(por ej: intro o develop, etc)
		-	Agregar el código y commitearlo:
				git add .
				git commit -m "Commit inicial"
		-	Subir el código a Github:
				git push origin nombreDeLaRama

	9. Instalado express js

		Página de Express JS:	http://expressjs.com/

		Express es un Framework de aplicaciones web Node.js minimalista y flexible que proporciona
		un conjunto robusto de características para aplicaciones web y móviles.

		Con una gran cantidad de métodos de utilidad HTTP y middlewares a su disposición,
		para crear una API robusta rápida y fácilmente.

		Express proporciona una capa delgada de funciones fundamentales de aplicaciones web,
		sin ocultar las funciones de Node.js que conoce y ama.

		Instalación:
			npm install express

		Uso básico:
			var express = require('express')
			const expressWebServer = express()
			const port = 3000
			expressWebServer.get('/', (req, res) => res.send('Funciona!'))
			expressWebServer.listen(port, () => console.log(`Servidor ejecutándose en el puerto ${port}`))
			* Con esto, al ejecutar la aplicación, ya queda corriendo un web server capaz de atender
				solicitudes, al cual se accede desde el navegor yendo a la url: http://localhost:3000
				Al ser una prueba devolverá un error si se intenta acceder a una url diferente de '/'.

		Routing (Ruteo):	http://expressjs.com/en/guide/routing.html
			El enrutamiento se refiere a determinar cómo una aplicación responde a una solicitud del
			cliente a un punto final particular (Endpoint), que es una URI (o ruta) y un método de solicitud
			HTTP específico (GET, POST, etc.).

		Documentación de la API:	http://expressjs.com/en/4x/api.html

		Instalación de Nodemon:

			Paquete NPM que reincia automáticamente la ejecución de nuestro proyecto
			cada vez que detecta que el mismo es modificado.

				Instalación:
					npm install -D nodemon   // Con -D le decimos a NPM que instale el paquete solo como una
											 // dependencia de desarrollo. Una dependencia de desarrollo no
											 // será incluída cuando se haga un paquete productivo ("build")
											 // de la aplicación.
				Uso:
					nodemon index.js

				Agregado de un nuevo script al archivo package.json:
					"dev" : "nodemon index.js"
					* Para el uso del nuevo script ejecutar:
						npm run dev
						*	Npm solo reconoce por defecto los scripts "start" y "test",
							por lo que para ejecutar cualquier otro script hace falta
							agregar el parámetro run:
								npm run dev
								npm run miScript

	10. Configurando Eslint y Prettier

		Al configurar estas herramientas estamos estableciendo que todos los desarroladores involucrados
		en el proyecto deben respetar ciertos estandares de escritura y formato de código y a su vez
		fuerzan a que el código por todos sea similar.

		Instalación como dependencia de desarrollo:
			npm i -D eslint

		Inicialización de Eslint:
			node_modules\.bin\eslint --init
				*	En linux:
								./node_modules/.bin/eslint --init
			Va a preguntar que se desea chequear, elegir la opción más completa:
				"To check syntax, find problems, and enforce code style "
			Va a preguntar que tipo de módulos usa el proyecto, elegir la segunda opción:
				"CommonJS (require/exports)"
			Va a preguntar si usamos algún framework como React, elegir:
				"None of these"
			Va a preguntar si usamos TypeScript, elegir:
				"N"
			Va a preguntar dónde está corriendo nuestro proyecto, elegir:
				"Node"
				* Si estuvieramos trabajando con React, deberíamos elegir "Browser"
			Va a preguntar que estilo de formateo se desea utilizar, elegir:
				"Use a popular style guide"
			Va a preguntar específicamente que estilo deseamos utilizar, elegir:
				"Airbnb: https://github.com/airbnb/javascript"
			Va a preguntar como queremos que obtenga el archivo de configuración, elegir:
				"JSON"
			Va a preguntar si deseamos instalar algunas dependencias necesarias extras, elegir:
				"Y"
			Con esto se van a instalar las dependencias faltantes y se va a crear un archivo .eslintrc.json
			con todo lo configurado.

		Instalación de extensiones extra para VSCode:
			Buscar e instalar:
				Eslint
				Prettier

		Crear un archivo llamado ".prettierrc" y configurarlo a voluntad:
			{
				"tabWidth": 4,
				"useTabs": true,
				"semi": false,
				"singleQuote": true
			}

		Desde VSCode se puede aplicar el formateo presionando:
			Alt + Shift + F
		o F1 y buscando "Aplicar formato de documento con..." y eligiendo Prettier.

	11. Arrow Functions y Firacode

		Eslint marca como error cuando se utilizan funciones en lugar de arrow functions, por lo que es recomendable
		hacer la migración para también ganar legibilidad en el código.
			Para migrar de function a arrow functions:
				-	Se quita la palabra function
				-	Se agregar luego de los paréntesis la flecha: =>
				-	Si la función posee un solo parámetro, el mismo no necesita paréntesis que lo envuelvan:
						text => console.log(text)
				-	La función debe ser asignada a una constante:
						const printText = text => console.log(text)

		A veces Prettier marca como error cosas como por ejemplo que las arrow functions que reciben un solo parámetro
		no tengan el mismo envuelto entre paréntesis. Este aviso se deshabilita agregando al archivo ".eslintrc.json"
		en la sección "rules", lo siguiente:
			"arrow-parens":"off"
		Así como se agrega esta regla según como figura en el popup del alerta de Eslint, se pueden agregar las que se
		deseen.

		Instalación de fuente Firacode

			https://github.com/tonsky/FiraCode

			https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions

		Una vez descargada la fuente, darle doble click para que se instale.
		Una vez instalada ir a VSCode y agregar lo siguiente en este archivo:
			"C:\Users\Jonatandb\AppData\Roaming\Code\User\settings.json"
				"editor.fontFamily": "'Fira Code', Consolas, 'Courier New', monospace",
				"editor.fontLigatures": true,
				// Esto se activa en caso de querer que los simbolos similares se fusionen, por ej ===, =>, etc.

	12. Query Params

		Con express se pueden obtener fácilmente los parámetros pasados por url consultando
		el objeto request.query.

			Por ej, al consultar la url "http://localhost:4000/country?code=AR"
			el valor del la propiedad query del objeto request será este objeto:
				{ code: 'AR' }

		Si en lugar de devolver texto (lo que devuelve por default response.send()), queremos
			devolver por ejemplo contenido json (Content-Type: application/json), debemos
			utilizar el método json() de response:
				response.json( ...objeto json a devolver... )
			** Al verificarlo detecté que send() parece que ahora detecta cuando recibe un objeto
				json y automáticamente devuelve dicho objeto con el Content-Type: application/json

	13. Alternativa a Query Params
		https://www.tutorialspoint.com/expressjs/expressjs_url_building.htm

		También se puede utilizar request.params para obtener un objeto que contenga los parámetros
			pasados a una url, por ej:
				http://localhost:4000/languages/es
			Donde, "/languages" es la ruta y "es" es el parámetro.

		Esto se obtiene consultando la propiedad de tipo objeto, llamada params, del objeto request:
			request.query.params
		Para el caso anterior se obtendría:
			request.params: { lang: 'es' }

		Para que Express intercepte correctamente este tipo de ruta con parámetros, se debe configurar
			la misma de la siguiente manera:
				app.get('/languages/:lang', (req, res) => {
				* Donde ":lang" le dice a Express con que nombre vamos a consultar el parámetro recibido.

		Se pueden configurar rutas que reciban múltiples parámetros, de la siguiente manera:
			app.get('/languages/:lang/:country', (req, res) => {
			* Para consultar ambos valores se debe hacer así:
				request.params.lang
				request.params.country

	14. APIs REST y Postman

		API: Application Programming Interface

		REST: Representational State Transfer

		Una API REST funciona como un navegador:
			Un cliente hace una petición mediante el protocolo HTTP a un servidor, el servidor procesa la
			solicitud y devuelve una respuesta (ya sea en formato JSON o XML).
			Generalmente las API REST trabajan con el formato JSON como respuesta.

		Postman:
			Cliente REST recomendado para consumir API's

		https://code.tutsplus.com/es/tutorials/a-beginners-guide-to-http-and-rest--net-16340

		Verbos HTTP

		GET es el tipo más simple de método de solicitud HTTP; La que usan los navegadores cada vez que hace
		clic en un enlace o escribe una URL en la barra de direcciones. Indica al servidor que transmita los
		datos identificados por la URL al cliente. Los datos nunca deben ser modificados en el lado del
		servidor como resultado de una solicitud GET. En este sentido, una petición GET es de sólo lectura,
		pero por supuesto, una vez que el cliente recibe los datos, es libre de hacer cualquier operación con
		ella por su cuenta, por ejemplo, formatearla para su visualización.

		Una petición PUT se utiliza cuando se desea crear o actualizar el recurso identificado por la URL.
		 Por ejemplo:
			PUT /clients/robin
		 Podría crear un cliente, llamado Robin en el servidor. Usted notará que REST es completamente agnóstico
		 de servidor; No hay nada en la solicitud que informe al servidor cómo deben crearse los datos, sólo
		 que debería. Esto le permite intercambiar fácilmente la tecnología del servidor si la necesidad surge.
		 Las peticiones PUT contienen los datos que se utilizarán para actualizar o crear el recurso en el
		 cuerpo.

		DELETE debe realizar lo contrario de PUT; Debe utilizarse cuando desee eliminar el recurso identificado
		 por la URL de la solicitud.

		POST se utiliza cuando el procesamiento que desea que suceda en el servidor debe repetirse, si la
		 solicitud POST se repite. Además, las solicitudes POST deben causar el procesamiento del cuerpo de
		 la solicitud como un subordinado de la URL que está publicando.
		 Las solicitudes PUT se utilizan fácilmente en lugar de solicitudes POST, y viceversa. Algunos sistemas
		 utilizan sólo uno, algunos utilizan POST para crear operaciones y PUT para operaciones de actualización
		 (ya que con una solicitud PUT siempre proporcionan la URL completa), algunos incluso utilizan POST para
		 actualizaciones y PUT para crear.

	15. Definiendo nuestras rutas en un archivo diferente

		Se mueve la configuración de las rutas a un archivo independiente dentro de la carpeta routes.

	16. Definiendo la estructura de nuestra API

		Se crea una carpeta para la versión 1 de las rutas y dentro los archivos "users-routes.js" y "products-routes.js".
		Se crea una carpeta para la versión 1 de los controllers y dentro los archivos "users-controller.js" y "products-controller.js"

		Middlewares:
			https://www.tutorialspoint.com/expressjs/expressjs_middleware.htm

			Las funciones de middleware son funciones que tienen acceso al objeto de solicitud (req), el objeto de respuesta (res)
			y la siguiente función de middleware en el ciclo de solicitud-respuesta de la aplicación. Estas funciones se utilizan para
			modificar los objetos req y res para tareas como analizar cuerpos de solicitud, agregar encabezados de respuesta, etc.

		Desde "index.js" se llama a una función exportada dentro del archivo "routes/v1/index.js" que lo que hace es recibir la app de
		Express y hace uso del método ".use()" que se utiliza para establecer middlewares a ejecutarse cuando se reciban requests,
		entonces se configuran las rutas '/api/v1/users' y '/api/v1/products' y se configura para que la primera utilice
		como middleware el archivo "routes/v1/users-routes.js" y a la segunda el archivo "routes/v1/products-routes.js".
		Los archivos 'users-routes.js' y 'products-routes.js' a su vez ejecutan la funcionalidad de Express: express.Router() y luego
		configuran dicho objeto estableciendo que verbos http se van a atender (post, put, get, etc), por medio de que ruta y que
		funcionalidad se debe ejecutar, esta funcionalidad estará en los controllers ('users-controller.js', etc.).

		Con esto así configurado y con las funcionalidades establecidas en los controllers, la aplicación ya es capaz de responder
		cuando desde "Postman" o "Advanced REST client" se hagan solicitudes a los siguientes endpoints:

			GET a  http://localhost:4000/api/v1/users/get-all
			POST a http://localhost:4000/api/v1/users/create
			POST a http://localhost:4000/api/v1/users/update
			POST a http://localhost:4000/api/v1/users/delete

			GET a  http://localhost:4000/api/v1/products/get-all
			POST a http://localhost:4000/api/v1/products/create
			POST a http://localhost:4000/api/v1/products/delete


	17. Obteniendo parámetros desde una petición POST

		Body-parser:
			https://www.npmjs.com/package/body-parser
			Nos permite convertir y obtener los datos entrantes de una solicitud HTTP.
			Por ejemplo, cuando se desee crear un usuario, se va a hacer un request a la ruta "/create"	y desde ahí necesitamos
			acceder al body de la solicitud, que va a tener los datos del usuario que se desea crear.
			El request puede ser de varios Content-type, por ejemplo "Form data (www-url-form-encoded)", en este caso los datos enviados
			al servidor van a llegar en forma de parámetros (clave, valor) que se pueden leer desde request.body PERO solo si se
			instala y configurara body-parser de la siguiente manera:
				var bodyParser = require('body-parser')
				// parse application/x-www-form-urlencoded
				app.use(bodyParser.urlencoded({ extended: false }))
			con esto se puede obtener el contenido de los parámetros mediante request.body, ej:
				console.log('req.body', req.body)
				lo que devolverá algo como:
					req.body [Object: null prototype] { user: 'Jonatandb' }
			sino el resultado de request.body será -> undefined.
			Este uso es muy poco frecuente, ya que los parámetros y sus valores son tomados todos como del tipo string y a veces eso no
			es totalmente conveniente, ya que se necesita en algunos casos enviar datos booleanos o incluso arrays.
			Para que la API siga las prácticas recomendadas y sea considerada de calidad debe poder trabajar mediante la recepción de
			datos en formato JSON. Para esto habría que configurarla para que sea capaz de recibir y utilizar correctamente la información
			contenida en un objeto JSON.
			Esto se logra agregando lo siguiente:
				// parse application/json
				app.use(bodyParser.json())
				* Con esto permitimos el consumo de nuestra API utilizando el Content-Type: application/json
			con esto se puede obtener el contenido del objeto JSON recibido consultado request.body, ej:
				console.log('req.body', req.body)
			lo que devolverá algo como:
				req.body { user: 'Jonatandb' }
			Si el request posee un objeto JSON con diferentes tipos de datos en sus parámetros, el resultado obtenido será por ejemplo:
				req.body: {
					user: 'Jonatandb',
					password: '123Abc',
					isAdmin: true,
					permissions: [ 1, 4, 6 ]
				}

		Cómo almacenar de forma segura una contraseña:
			https://codahale.com/how-to-safely-store-a-password/

		bcrypt: Librería que ayuda a hashear passwords.
			https://www.npmjs.com/package/bcrypt

			Instalación:
				npm install bcrypt

			Uso asincrónico:
				Ya que la funcionalidad que hashea la contraseña (que luego almacenaremos en la base de datos) se demora su tiempo, es
				recomendable hacer que toda la funcionalidad de creación de usuario sea asíncrona y aguardar su finalización antes de
				devolver una respuesta al usuario (o API) que la está consumiendo.
				Para esto, a la función arrow que se ejecuta cuando se accede a la ruta '/api/v1/users/create' le anteponemos la palabra
				clave 'async':
					const createUser = async (req, res) => {
				Luego, en llamada a la función que se demora (la que hashea la contraseña) se antepone la palabra clave 'await':
					const hash = await bcrypt.hash(req.body.password, 6)
				Con esto, se detendrá la ejecución de la aplicación hasta que el hasheo esté realizado.
				Para capturar posibles errores durante el hasheo, se puede envolver el código en un bloque try-catch de la siguiente
				manera:
					const createUser = async (req, res) => {
						try {
							const hash = await bcrypt.hash(req.body.password, 6)
							res.send('User created!')
						} catch (error) {
							res.status(500).send({
								status: 'ERROR',
								message: 'No se pudo hashear la contraseña, error: ' + error.message
								// El parámetro error posee siempre una propiedad llamada 'message'
							})
						}
					}
				* El uso de la palabra clave await es posible gracias a que la función bcrypt.hash() devuelve una Promise.
				* Toda función que hace uso de la palabra clave await debe tener en su definición la palabra clave async.
				* Todo error producido en una Promise puede ser capturado mediante el bloque catch de un try-catch.
				Con esto garantizamos que nuestra aplicación no se va a "caer" en tiempo de ejecución, esto es, que no va a dejar de responder
				por causa de un error.

	18. Conectando con mongodb

		Utilización de variables de entorno

			Es importante que nunca se suba al repositorio el archivo con variables de entorno
				por la naturaleza de los datos que las mismas contienen, generalmente, cadenas
				de conexión, credenciales, y toda información dinámica específica y privada de
				nuestra aplicación. Por esta razón es que suele agregar este archivo a la lista
				de archivos ingorados por Git dentro del archivo ".gitignore"

			Se debe crear un archivo ".env"

			Para poder utilizar las variables de entorno, se debe instalar el paquete dotenv:
				npm install dotenv
				El cual se importa así:
					const dotenv = require('dotenv')
				Y se debe inicializar así:
					dotenv.config();
					Esto lee la información dentro del archivo ".env" y la deja a nuestra disponsición para su consulta.

			Para consultar el valor de las variables de entorno (junto con las configuradas en el archivo ".env")
				se debe consultar la propiedad env del objeto process:
					console.log(process.env.nombreDeLaVariable)
				* Si la máquina ya tenía una variable de entorno definida con el mismo nombre, se obtiene su valor,
					no se va a obtener el que esté en el archivo ·.env".

			Para evitar errores cuando por alguna razón no se establezcan correctamente las variables de entorno, se suele
			utilizar el simnolo || de la siguiente manera:
				const PORT = process.env.PORT || 5555
			de esta forma, si no se obtiene el valor de la variable de entorno PORT, se trabajará por defecto con el valor 5555.

		Utilizando Mongoose para conectarse a MongoDB

			https://www.npmjs.com/package/mongoose

			https://mongoosejs.com/

			Instalación:

				npm install mongoose

			Uso de Mongoose:

				const mongoose = require('mongoose')
				mongoose
					.connect("mongodb://user:pass@localhost/databasename", {
						useNewUrlParser: true,
						useUnifiedTopology: true
					})
					.then(() => {
						console.log('Conectado a MongoDB!')
					})
					.catch(err => {
						console.log('Error conectando a MongoDB!', err)
					})
